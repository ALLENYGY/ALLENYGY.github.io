```js RunJS="生成归档"
// 归档文件名
const archiveFileName = 'Archive.md';
//排除的文件或文件夹
const excludes = [
    "归档和分类.md",
    "Home.md",
    "Task Management.md",
    "Others"
];
// 仅在下列文件夹中的文件才显示
const onlyFolers = [
	//"开发笔记",
	"Algorithm",
	"Data-Analysis",
	"Program" ,
	"Web",
	"Database-Management",
	"Research",
	"DeepLearning", 
	"Math",
	"Share",
	"Computer-Organization",
	"English",
    "Network",
	"Contest",             
	"Operating-System",
	"Tools",
];
// 格式 {yearmonth:[link, link]}
const files = {};
const dv = DataviewAPI;
dv.pages().sort(p => p.file.ctime, 'desc')
	.map(p => {
		// 排除的文件或文件夹则跳过
		if (excludes.includes(p.file.path) ||
			excludes.includes(p.file.folder) ||
			(onlyFolers && onlyFolers.length && !onlyFolers.some(f=>new RegExp(`^${f}`).test(p.file.folder)))
		) return;
		// 初始化数组
		const key = p.file.ctime.year+''+p.file.ctime.month;
	    if(!files[key]) files[key] = [];
	    // 把相同年月的放到一个数组中
	    files[key].push(p.file.link);
	});
// 把年月倒序排序
const yearmonths = Object.keys(files)
	.sort((a, b) => b - a);

// 输出年月及文件列表
let content = '# Archive\n\n';

yearmonths.forEach((year_month)=>{
	const links = files[year_month]
	content += "## " + year_month.substr(0, 4) + '年' + year_month.substr(4, 2) + '月' + "\n\n"
    content += dv.markdownList(links) + "\n";
});
app.vault.adapter.write(archiveFileName, content);
```

```js RunJS="生成分类"
// 分类文件名
const cateFileName = 'Class.md';
//排除的文件或文件夹
//排除的文件或文件夹
const excludes = [
    "归档和分类.md",
    "Home.md",
    "Task Management.md",
];
// 仅在下列文件夹中的文件才显示
const onlyFolers = [
	//"开发笔记",
	"Algorithm",
	"Data-Analysis",
	"Program" ,
	"web",
	"Database-Management",
	"Research",
	"DeepLearning", 
	"Math",
	"Share",
	"Computer-Organization",
	"English",
    "Network",
	"Contest",             
	"Operating-System",
	"Tools",
];
//排序，仅支持文件夹排序
const sortBy = [
    //"开发笔记",
    //"javascript",
];
// 格式 {"folder":[link, link]}
const files = {};
const dv = DataviewAPI;
dv.pages()
	.sort(p => p.file.ctime, 'desc')
	.map(p => {
		// 脚本自身及排除的文件或文件夹则跳过
		if (excludes.includes(p.file.path) ||
			excludes.includes(p.file.folder) ||
			(onlyFolers && onlyFolers.length && !onlyFolers.some(f=>new RegExp(`^${f}`).test(p.file.folder)))
		) return;
		// 初始化数组
	    if(!files[p.file.folder]) files[p.file.folder] = [];
	    // 把相同的分类放到一个数组中
	    files[p.file.folder].push(p.file.link);
	});
// 把文件夹按名称正序排序
let folders = Object.keys(files)
	.sort((a, b) => a.localeCompare(b, undefined, { numeric: true }));
// 把未分类的文件放到最后
if(folders[0] === "") {
    const shift = folders.shift()
    folders.push(shift);
}
// 第一次把folders按sortby排序
const sortByIndex = sortBy.reduce((acc, curr, index) => {
    acc[curr] = index;
    return acc;
}, {});
folders.sort((a, b) => {
    // 获取a和b在sortBy中的索引，如果不存在则默认为sortBy.length（即放在末尾）
    const indexA = sortByIndex[a] !== undefined ? sortByIndex[a] : sortBy.length;
    const indexB = sortByIndex[b] !== undefined ? sortByIndex[b] : sortBy.length;
    // 按照索引值进行排序，索引越小越靠前
    return indexA - indexB;
});
//第二次把folders按sortby前缀排序
let newFolders = [];
sortBy.forEach((item) => {
    newFolders = [...newFolders, ...folders.filter(f=>f.startsWith(item))];
});
// 第三次，把folders中剩余的合并到newFolers
newFolders = [...newFolders, ...folders.filter(f=>!newFolders.includes(f))]
// 去重
folders =  newFolders.filter((item, index, array) => array.indexOf(item) === index);
// 嵌套输出文件夹及文件列表
const tree = {};
let content = '# Class\n\n';
folders.forEach(folder => {
    let subs = folder.split('/');
    let currentNode = tree;
    let path = '';
    subs.forEach((sub, index) => {
        //path += (index ? '/' : '') + sub;
        // 如果不在目录结构的列表才输出，防止重复输出父分类和祖先分类
        if(!currentNode[sub]){
            //输出标题
            content += `${"#".repeat(index+2)} ${sub||"未分类"}\n\n`
            // 输出链接
            //content += `${"\t".repeat(index+1)}- list\n`
            let links = files[folder]
            // links = dv.markdownList(links).replace(/- \[\[/g, `${"\t".repeat(index+1)}- [[`); 
            links = dv.markdownList(links).replace(/- \[\[/g, `- [[`); 
            content += links + "\n"
        }

        // 实时计算目录结构
        if (!currentNode[sub]) {
            currentNode[sub] = {};
        }
        currentNode = currentNode[sub];
    });
});
/* 不嵌套输出文件夹及文件列表
let content = '';
folders.forEach((folder)=>{
	const links = files[folder]
    content += "### " + (folder.replace(/\//g, " / ")||"未分类") + "\n\n"
    content += dv.markdownList(links) + "\n";
});*/
app.vault.adapter.write(cateFileName, content);
```
